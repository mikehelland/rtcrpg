<!DOCTYPE html>
<html>
    <head>
        <style>
            body {
                /*background: rgba(0, 0, 0, 0) linear-gradient(135deg, rgb(249, 241, 232) 0%, rgb(205, 214, 227) 100%) repeat scroll 0% 0%;*/
                background: rgba(0, 0, 0, 0) linear-gradient(135deg, 
                rgb(90, 87, 83) 0%, rgb(50, 53, 56) 100%) repeat scroll 0% 0%;
                color:white;
            }
            #user-list {
                display: flex;
                flex-wrap: wrap;
            }
            .user-panel {
                position: relative;
                width: 30%;
            }
            video {
                width: 100%;;
            }
        </style>
    </head>
    <body>
        <span id="connected-status">not connected</span><br>
        <div id="user-list">
            <div id="you" class="user-panel">
                <div id="your-name"></div>
                <video id="your-video"></video>
            </div>
    
        </div>
        <div id="activity-log"></div>

        <script src="/socket.io/socket.io.js"></script>
        <!--<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>-->
        <script>

        // show our name and face
        var userName = window.location.search.slice(1) || (Math.round(Math.random() * 100000) + "")
        var connectedStatusEl = document.getElementById("connected-status")
        document.getElementById("your-name").innerHTML = userName
        var v1 = document.getElementById('your-video')
        var localStream
        navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
        }).then((stream) => {
            v1.srcObject = stream
            localStream = stream
            v1.muted = true
            v1.play()

            socket.emit("join", {
                name: userName
            })
        })
        var activityLog = document.getElementById("activity-log")
        var log = text => {
            activityLog.innerHTML = text + "<br>" + activityLog.innerHTML
        }

        // this is for the other users
        var userListEl = document.getElementById('user-list')
        var remoteUsers = {}
        var setupNewUser = (name, data) => {
            log(name + " joined")
            remoteUsers[name] = {id: data.id}
            userEl = document.createElement("div")
            userEl.className = "user-panel"
            nameEl = document.createElement("div")
            nameEl.className = "user-name"
            nameEl.innerHTML = name
            videoEl = document.createElement("video")
            userEl.appendChild(nameEl)
            userEl.appendChild(videoEl)
            userListEl.appendChild(userEl)
            remoteUsers[name].div = userEl
            remoteUsers[name].video = videoEl
        }
        
        // get touch with the signaling server
        var socket = io("")

        socket.on("joined", users => {
            connectedStatusEl.innerHTML = "connected"
            updateUsers(users)
        })
        var firstJoin = true
        socket.on("update-user-list", users => {
            updateUsers(users)
        })
        var updateUsers = users => {
            for (var name in users) {
                if (name == userName) continue;
                if (!remoteUsers[name]) {
                    setupNewUser(name, users[name])
                }
                else {
                    remoteUsers[name].id = users[name].id
                }
                if (firstJoin && localStream) {
                    callUser(name)
                }
            }
            for (name in remoteUsers) {
                if (!users[name]) {
                    log(name + " disconnected")
                    userListEl.removeChild(remoteUsers[name].div)
                    remoteUsers[name].peerConnection.close()
                    delete remoteUsers[name]
                }
            }
            if (Object.keys(remoteUsers).length === 0) {
                //userListEl.innerHTML = "no users yet"
            }
            firstJoin = false
        }

        socket.on("disconnect", () => {
            connectedStatusEl.innerHTML = "not connected"
        });


        socket.on("incoming-call", async data => {
            console.log("incoming-call")
            var name = data.callerName
            var user = remoteUsers[name]
            if (!user) {
                console.log("incoming caller doesn't exist", name)
                // todo not there
            }
            if (user.peerConnection) {
                console.log("incoming connection already exists", name)
                // todo 
            }

            user.caller = true
            user.peerConnection = createPeerConnection(user)

            localStream.getTracks().forEach(track => user.peerConnection.addTrack(track, localStream));

            await user.peerConnection.setRemoteDescription(data.offer)

            const answer = await user.peerConnection.createAnswer();
            await user.peerConnection.setLocalDescription(new RTCSessionDescription(answer));
            
            socket.emit("make-answer", {
                answer,
                to: data.socket
            });
        });

        var isAlreadyCalling = false
        socket.on("answer-made", async data => {
            console.log("answer-made", data)
            var name = data.calleeName
            var user = remoteUsers[name]
            if (!user) {
                console.log("callUser doesn't exist", name)
                // todo not there
            }
            if (!user.peerConnection) {
                console.log("callUser connection doesn't exists", name)
                // todo 
            }

            await user.peerConnection.setRemoteDescription(
                new RTCSessionDescription(data.answer)
            );
            
            //user.peerConnection.ontrack = function({ streams: [stream] }) {
            //    user.video.srcObject = stream;
            //    user.video.play()
            //};
        });

        socket.on("candidate", data => {
            console.log("oncandidate", data)
            var name = data.caller
            var user = remoteUsers[name]
            if (!user) {
                console.log("callUser doesn't exist", name)
                // todo not there
            }

            console.log("label", data.label)
            var candidate = new RTCIceCandidate({
                sdpMLineIndex: data.label,
                //sdpMid: data.id,
                candidate: data.candidate + "",
            })
            
            user.peerConnection.addIceCandidate(candidate)
        })

        async function callUser(name) {
            console.log("call")
            var user = remoteUsers[name]
            if (!user) {
                console.log("callUser doesn't exist", name)
                // todo not there
            }
            if (user.peerConnection) {
                console.log("callUser connection already exists", name)
                // todo 
            }
            
            user.peerConnection = createPeerConnection(user)

            localStream.getTracks().forEach(track => user.peerConnection.addTrack(track, localStream));

        }; 


        function createPeerConnection(user) {
            var peerConnection = new RTCPeerConnection({
                iceServers: [     // Information about ICE servers - Use your own!
                    {
                        urls: "stun:stun.stunprotocol.org"
                    }
                ]
            });

            peerConnection.onicecandidate = function (event) {
                console.log("onicecandidate")
                if (event.candidate) {
                    socket.emit("candidate", {
                        to: user.id,
                        candidate: event.candidate.candidate,
                        label: event.candidate.sdpMLineIndex,
                        id: event.candidate.sdpMid
                    });
                }
            };

            peerConnection.onnegotiationneeded = function () {
                console.log("onnegotiatedneedeed")
                peerConnection.createOffer().then(function(offer) {
                    return peerConnection.setLocalDescription(offer);
                })
                .then(function() {
                    console.log("call-user", user.id)
                    socket.emit("call-user", {
                        offer: peerConnection.localDescription, 
                        to: user.id
                    })
                })
                .catch((error) => console.error(error));
            };

            peerConnection.ontrack = function({ streams: [stream] }) {
                user.video.srcObject = stream;
                user.video.play()
            };
            /*peerConnection.onremovetrack = handleRemoveTrackEvent;
            peerConnection.oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
            peerConnection.onicegatheringstatechange = handleICEGatheringStateChangeEvent;
            peerConnection.onsignalingstatechange = handleSignalingStateChangeEvent;*/
            return peerConnection
        }


        </script>
    </body>
</html>